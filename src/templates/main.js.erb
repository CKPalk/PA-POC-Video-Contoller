/** main.js.erb
 *  This script is run at the end of matched documents.
*/

/* TODO: Move these constants to the rb file **********************************/
const ATTEMPTS_TO_LOCATE_VIDEOS = 3
const LOCAL_STORAGE_VIDEOS_KEY = '<%= @local_storage_videos_key %>'
const CALLOUT_DISPLAY_LENGTH = 3000 //ms (3 seconds)

const GOOGLE_API_KEY = 'AIzaSyB7lbZlbuGC3fy6p0kjfdk0bIKf6v00Amo'
/******************************************************************************/

function findBestContainer(video) {
  const isGoodContainer = ({ offsetWidth, offsetHeight }) => (
    offsetWidth  === video.offsetWidth &&
    offsetHeight === video.offsetHeight
  )

  let container = video.parentElement
  while (isGoodContainer(container.parentElement))
    container = container.parentElement
  return container
}

function getStyleValue(element, property) {
  return window.getComputedStyle(element).getPropertyValue(property)
}

function removeElement(element) {
  try {
    element.parentElement.removeChild(element)
  } catch(e) {
  }
}

function endVideo(video) {
  video.currentTime = video.duration
}

function createFeedbackForm(video, recordID) {

  const container = findBestContainer(video)

  const feedbackForm = document.createElement('div')
  feedbackForm.style.position = 'absolute'
  feedbackForm.style.top = '0'
  feedbackForm.style.width = `${video.offsetWidth}px`
  feedbackForm.style.height = `${video.offsetHeight}px`
  feedbackForm.style.pointerEvents = 'none'
  feedbackForm.style.overflow = 'hidden'

  feedbackForm.className = 'pa-feedbackForm'
  feedbackForm.innerHTML = `
    <div id='pa-popout' class='pa-popout'>
      <img class='pa-popout__logo' src='${chrome.extension.getURL("logo.png")}'></img>
      <a id='pa-popout-snooze' class='pa-popout__button button-reject'>Snooze</a>
      <a id='pa-popout-like' class='pa-popout__button button-accept'>Like</a>
    </div>
  `

  container.appendChild(feedbackForm)

  const upsertScreenshotAndSentiment = sentiment => {
    const update = {
      screenshot: getVideoScreenshot(video)
    }
    if (sentiment) {
      Object.assign(update, {sentiment})
    }
    upsertAdvertismentRecord(recordID, update)
  }

  const defaultScreenshot = setTimeout(() => {
    upsertScreenshotAndSentiment()
  }, 1000)

  // Add events to buttons on feedbackForm
  const like_button = document.getElementById('pa-popout-like')
  addClickEvent(like_button, () => {
    clearTimeout(defaultScreenshot)
    upsertScreenshotAndSentiment(VIDEO_SENTIMENT.LIKE)
    removeElement(feedbackForm)
  })

  const snooze_button = document.getElementById('pa-popout-snooze')
  addClickEvent(snooze_button, () => {
    clearTimeout(defaultScreenshot)
    upsertScreenshotAndSentiment(VIDEO_SENTIMENT.SNOOZE)
    endVideo(video)
    removeElement(feedbackForm)
  })

  return feedbackForm //document.getElementById('pa-popout')
}

function upsertAdvertismentRecord(id, update={}) {
  return getStorageRecord(LOCAL_STORAGE_VIDEOS_KEY)
    .then((videos=[]) => {
      const videoIndex = videos.findIndex(v => v.id === id)
      if (videoIndex === -1) {
        // Video not found, create new record and append at end
        videos.push(Object.assign({}, { id, created: new Date() }, update))
      } else {
        // Otherwise we extend the object with our update
        Object.assign(videos[videoIndex], update)
      }

      // Save our changes
      saveStorageRecord(LOCAL_STORAGE_VIDEOS_KEY, videos)
    })
}

function displayCalloutForForm(video) {
  const container = findBestContainer(video)

  const callout = document.createElement('div')
  callout.className = 'pa-callout'
  callout.innerHTML = `
    <img class='pa-callout__logo' src='${chrome.extension.getURL("logo.png")}'></img>
    <span>Let us know how you feel about this ad!</span>
  `

  // TODO: Fade in
  container.appendChild(callout)
  const videoDurationInMS = (video.duration || 0) * 1000
  // Show callout for 50% of ad duration, minimum 1s
  const callout_display_length = Math.max(videoDurationInMS * 0.5, 1000)
  const defaultRemoveTimeout = setTimeout(removeElement, callout_display_length, callout)

  addClickEvent(callout, () => {
    clearTimeout(defaultRemoveTimeout)
    const feedbackForm = document.getElementById('pa-popout')
    if (feedbackForm) {
      feedbackForm.className = `${feedbackForm.className} open`
    }
    callout.className = `${callout.className} fader fadeOut`
    setTimeout(removeElement, <%= @fade_out_delay_ms %>, callout)
  })

}

/**
 * Display a feedbackForm over the video letting the user know
 * that an advertisement was blocked.
 *
 * TODO: Clicking feedbackForm should show the user the menu, listing blocked ads
 *
 * @param   {Object}  video  The video HTML element
 * @return  {Object}         The feedbackForm HTML element
 */
function displayFeedbackForm(video, recordID) {
  const feedbackForm = createFeedbackForm(video, recordID)
  const _onloadstart = video.onloadstart
  video.onloadstart = () => { removeElement(feedbackForm); _onloadstart() }
  displayCalloutForForm(video)
  return feedbackForm
}

function ISOStringToSeconds(string) {
  const hours   = parseInt((string.match(/\d{1,2}(?=H)/) || [])[0]) || 0,
        minutes = parseInt((string.match(/\d{1,2}(?=M)/) || [])[0]) || 0,
        seconds = parseInt((string.match(/\d{1,2}(?=S)/) || [])[0]) || 0

  return (hours * 60 * 60) + (minutes * 60) + seconds
}

/**
 * Get a screenshot in base64 format of the video.
 * @param   {Element}  video  Ad HTML5 video element
 * @return  {String}          Base64 data
 */
function getVideoScreenshot(video) {
  const canvas = document.createElement('canvas'),
        context = canvas.getContext('2d'),
        width  = video.scrollWidth  || video.clientWidth  || 480
        height = video.scrollHeight || video.clientHeight || 360

  canvas.width  = width
  canvas.height = height
  context.drawImage(video, 0, 0, width, height)

  return canvas.toDataURL()
}

/**
 * Get information about the video for a package to save in local storage.
 * This information will be used by the popup and context menu.
 * @param   {Object}  video  Advertisment video element
 * @return  {Promise}        Promise to supply video information
 */
function getVideoData(video={}) {

  const {
    duration, src, currentSrc,
    scrollWidth, clientWidth,
    scrollHeight, clientHeight
  } = video

  return {
    duration: Number(duration) || null,                     // Integer?
    source: String(src || currentSrc) || null,              // String?
    dimensions: {
      width:  Number(scrollWidth  || clientWidth)  || null, // Integer?
      height: Number(scrollHeight || clientHeight) || null, // Integer?
    },
    sentiment: VIDEO_SENTIMENT.NONE                         // String
  }
}

/**
 * Removes ads from youtube.
 */
function removeKnownYoutubeAds() {
  const byCN = cn => Array(...document.getElementsByClassName(cn))
  const byID = id => Array(...document.getElementById(id))

  const classes_to_remove = [
    'video-ads',
    'iv-promo'
  ]
  const ids_to_remove = []

  const remove = e => {
    // e.style.opacity = 0
    removeElement(e)
  }

  classes_to_remove.forEach(cls => { byCN(cls).map(remove) })
  ids_to_remove.forEach(id => { remove(byID(id)) })
}

/**
 * Pauses and shows feedbackForm over video.
 * @param   {Object}  video  A video element on the page.
 */
function handleVideo(video) {
  video.onloadstart = () => { handleVideo(video) }

  const pageUrl = window.document.URL

  const pageMatching = {
    youtube: {
      site_regex: /.*:\/\/.*\.youtube\.com\/.*/,
      video_regex: /\?v=(.*?)(&|$)/
    }
  }

  if (pageUrl.match(pageMatching.youtube.site_regex)) {

    // TODO: This throws an error for manipulating the canvas used to generate ad thumbnail
    removeKnownYoutubeAds()


    // ID is capture group 1 of Regex
    const videoId = (pageUrl.match(pageMatching.youtube.video_regex) || [])[1]
    if (!videoId) return // No video id means we cannot ensure we are blocking an ad for youtube

    const url = 'https://www.googleapis.com/youtube/v3/videos' +
                `?id=${videoId}` +
                '&part=contentDetails' +
                `&key=${GOOGLE_API_KEY}`

    ajax_get(url, {}, response => {
      const { items: [ video_details ], pageInfo: { totalResults } } = JSON.parse(response)
      if (totalResults !== 1) return // Supplying video id should return only one result
      const { id, contentDetails: { duration } } = video_details
      const videoDuration = ISOStringToSeconds(duration)

      const handleAdOrNot = (v) => {
        // If video durations differ, assume video playing is ad.
        const isAd = Math.abs(v.duration - videoDuration) > 3
        if (isAd) {
          const recordID = generateGUID()
          upsertAdvertismentRecord(recordID, getVideoData(v))
          displayFeedbackForm(v, recordID)
        }
      }

      if (!video.duration) {
        video.ondurationchange = () => {
          if (!video.duration) return
          else video.ondurationchange = noop
          handleAdOrNot(video)
        }
      } else {
        handleAdOrNot(video)
      }
    })
  }
}

function isProjectAwesomePage() {
  return !!window.document.URL.match(/https?:\/\/(nightly\.|qa0\.)?projectawesome\.xyz\/.*/)
}


/**
 * Searches document for video elements, if there none it tries attempts
 * searching the document again after progressively long timeouts.
 * Any videos found are then processed.
*/
function main(attempts_left) {
  if (attempts_left === 0) return
  if (isProjectAwesomePage()) return

  // Find all <video /> elements in the document
  const videos = Array(...document.getElementsByTagName('video'))

  if (videos.length === 0) {
    const timeout = parseInt(2 * attempts_left * 1000)
    setTimeout(main, timeout, attempts_left - 1)
    return
  }

  videos.forEach(video => {
    video.crossOrigin = 'anonymous'
    // If the video is loaded we run handleVideo, otherwise we wait on video
    // callback event for when it's loaded.
    if (video.readyState === 4) {
      handleVideo(video)
    } else {
      video.onloadeddata = () => {
        video.onloadeddata = noop
        handleVideo(video)
      }
    }
  })
}



if (typeof main === 'function') {
  main(ATTEMPTS_TO_LOCATE_VIDEOS)
}
